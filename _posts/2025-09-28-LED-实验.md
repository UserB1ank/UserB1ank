---
title: LED实验
date: '2025-09-28 12:06:33'
permalink: /post/led-experiment-z1eoc9g.html
tags:
  - ARM
  - 嵌入式
layout: post
published: true
---



# LED实验

# 实验简介

MX6U的板子上有个LED灯，控制这个灯的寄存器是GPIO3，当GPIO3输出低电平则灯亮，高电平则灯灭。依照教程中所述，这种寄存器并非实际的寄存器，而是一块确定的内存，这块内存专门被用来作为GPIO3。

GPIO作为板子上的一个设备，在使用之前需要使能相应设备的时钟，可以理解为启用设备。正点原子的教程为了便于入门，就将所有的时钟都使能。负责使能时钟的模块叫CCM。

CCM，全称`Clock Control Module`，这是整个芯片的时钟控制中心。I.MX6U这块板子的CCM的寄存器代号为CCM_CCGR0~CCM_CCGR6。每个寄存器有32位，

‍

![image](/assets/images/image-20250929193154-uqdu9zz.png)

每两个bit控制一个外设的时钟，每个时钟有四种模式。

![image](/assets/images/image-20250929193220-aocot8t.png)

‍

在I.MX6U中，GPIO的命名规则为`IOMUXC_SW_MUX/PAD_CTL_PAD_GPIXX_IOXX`，本实验需要使用的GPIO3的名字为

​`IOMUXC_SW_PAD_CTL_MUX_GPIO1_IO03`​和`IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03`​，这两个的主要区别是在第三个字段，它们分别为MUX和PAD。直接翻译过来的话，MUX对应复用，PAD对应焊盘，这两个寄存器的作用与其命名一样，`MUX_GPIO1_IO03`用来设置GPIO的复用模式，因为这块芯片的GPIO不仅仅可以用作IO，还可以用作别的功能。PAD则是设置GPIO的电气属性，也就是配置GPIO，我对这些属性不了解，直接跟着教程走了。

当设置好了GPIO的属性和模式，就要向GPIO3中发送数据，需要设置GPIO3为输出模式，并向其中输入低电平也就是0。这个操作涉及到了另外两个寄存器，分别是`GPIOx_DR`​和`GPIOx_GDIR`。

DR指的是DATA REGISTRY，其作用是传输数据；

![image](/assets/images/image-20250929213235-idndjh4.png)

DIR指的是DIRECTION REGISTRY，其作用是控制DR是用作输入还是输出。

![image](/assets/images/image-20250929213305-zu07e9d.png)

整个实验的流程可以总结为下面几步：

1. 使能设备的时钟
2. 设置GPIO3的模式
3. 设置GPIO3的属性
4. 控制GPIO3输出低电平
5. 编译文件
6. 烧录到sd卡
7. 实机测试

# 实验步骤

## 1.使能时钟

‍

从芯片参考手册中查找所有CCM_CCGR寄存器的地址，将其全部启用也就是设置为0XFFFFFFFF。

![image](/assets/images/image-20250929194355-qvtfxdw.png)

从图中可以看到CCGR01的地址为`0X020C4068`，依次找到所有寄存器的地址，并为其赋值。对应的代码如下。

```arm
.global _start

_start:
ldr r1, =0xffffffff 
ldr r0, =0x020c4068 @CCGR0
str r1, [r0]

ldr r0, =0x020c406c @CCGR1
str r1, [r0]

ldr r0, =0x020c4070 @CCGR2
str r1, [r0]

ldr r0, =0x020c4074 @CCGR3
str r1, [r0]

ldr r0, =0x020c4078 @CCGR4
str r1, [r0]

ldr r0, =0x020c407c @CCGR5
str r1, [r0]

ldr r0, =0x020c4080 @CCGR6
str r1, [r0]
```

## 2.设置GPIO01_03的复用模式

为了让GPIO3输出低电平，我们要设置其为IO模式。查找芯片手册，查看对应的bit位和寄存器地址。

![image](/assets/images/image-20250929200711-g6j81lz.png)

从图中可以看出，芯片地址为`0x020e0068`，我们需要将低4位设置为0101，也就是0x5。对应的代码如下

```arm
ldr	r1,	=0x5
ldr	r0,	=0x020e0068
str	r1,	[r0]
```

## 3.设置GPIO的属性

这些属性我并不熟悉，交给GPT去解释了

```arm
ldr	r0,	=0x020e02f4
ldr	r1,	=0x10b0
str r1,[r0]
```

![image](/assets/images/image-20250929214021-u32e1tn.png)

## 4.让GPIO01_IO03输出低电平

查找手册，找到GPIO_GDIR，设置第三个bit，对应的也就是GPIO3，为输出。

![image](/assets/images/image-20250929214556-7wg9ngz.png)

![image](/assets/images/image-20250929214342-nwc2a4y.png)

```arm
ldr r0,	=0x0209c004	@GPIO1_GDIR
ldr r1, =0x1
str r1,	[r0]

ldr r0,	=0x0209c000	@GPIO1_DR
ldr r1,	=0
str r1,	[r0]
```

末尾加个死循环，让程序持续运行

```arm
loop:
	b   loop
```

## 5.编译文件

```shell
arm-linux-gnueabihf-gcc -g -c led.s -o led.o
```

-g产生调试信息，-c只编译不链接。编译时报错了，提示需要插入一个新行作为结尾。

![image](/assets/images/image-20250929215821-l39dazp.png)

按了个回车后再编译，通过了。

![image](/assets/images/image-20250929215900-x67bm7c.png)

下一步是链接文件，链接的时候需要指定程序起始地址，我的板子是512MB版本的，用户可用内存的起始地址为0X80000000，终止地址为0X9FFFFFFFF。教程中为了不和之后要讲的linux uboot起始地址搞混，统一将起始地址设置为0x80000000。

```shell
arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf
```

-Ttext意思是指定起始地址。

此时生成的文件是elf文件，但是实验需要的是二进制格式，并非ELF格式。接下来需要用objcopy转换格式

```shell
arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin
```

## 6.烧录文件

这里烧录文件用的软件叫imxdownload，教程中有提供，似乎别的烧录软件不能用，因为这个软件会做特定的处理。

准备一张SD卡，挂载到虚拟机中，然后将led.bin烧录到其中。

![image](/assets/images/image-20250929222334-6f6qi3i.png)

## 7.实机测试

![IMG20250929222650](/assets/images/IMG20250929222650-20250929222747-1vwldnj.jpg)

将sd卡插入背面的卡槽中，金手指朝着板子正面。

![IMG20250929222722](/assets/images/IMG20250929222722-20250929222832-vfc0syr.jpg)

调整启动模式，1、7拨上去。上电，开机！

![IMG20250929223158](/assets/images/IMG20250929223158-20250929223301-sdcueiv.jpg)

一次点亮！😃LED实验还是简单的，嘻嘻。

# 总结

这是我第一次正式玩开发板，教程还是很详细的，跟着做完全没问题，也能学到很多知识。我跟了一遍下来，感觉涉及到的知识有大约一半没接触过，主要是数字电路相关的，其他的汇编、linux、语法、调试等等，都已经在之前的计算机学习生涯中接触到了。

通过这次小实验，我大抵了解了嵌入式开发的思路，

确定自己想要的功能，然后查阅开发板文档，寻找涉及到的部件的操作方式，查阅芯片手册，了解各类寄存器的作用，控制寄存器从而控制部件。

说到底其实跟软件开发差不多，只是这次查的不是程序或者库文档，而是各种芯片、主板的手册。
